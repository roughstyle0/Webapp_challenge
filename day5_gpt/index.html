<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>レンズの厚み（薄さ）比較シミュレーター｜眼鏡店向け</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .soft-shadow { box-shadow: 0 10px 30px rgba(0,0,0,.06); }
    .ring-soft { box-shadow: 0 0 0 1px rgba(15,23,42,.08) inset; }
    .grid-dot {
      background-image: radial-gradient(rgba(15,23,42,.08) 1px, transparent 1px);
      background-size: 14px 14px;
      background-position: 0 0;
    }
    input[type="range"] { -webkit-appearance: none; appearance: none; height: 6px; border-radius: 999px; background: rgba(15,23,42,.12); outline: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 999px; background: white; border: 1px solid rgba(15,23,42,.18); box-shadow: 0 6px 18px rgba(0,0,0,.12); }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 999px; background: white; border: 1px solid rgba(15,23,42,.18); box-shadow: 0 6px 18px rgba(0,0,0,.12); }
    .smooth { transition: all .22s ease; }
    .mono-num { font-variant-numeric: tabular-nums; }
  </style>
</head>

<body class="min-h-screen bg-slate-50 text-slate-900">
  <div class="mx-auto max-w-5xl px-4 py-6 sm:py-10">
    <!-- Header -->
    <header class="mb-6 sm:mb-8">
      <div class="flex items-start justify-between gap-4">
        <div>
          <h1 class="text-xl sm:text-2xl font-semibold tracking-tight">
            レンズの厚み（薄さ）比較シミュレーター
          </h1>
          <p class="mt-1 text-sm sm:text-base text-slate-600">
            厳密計算ではなく、<span class="font-medium text-slate-700">「度数が強いほど厚く」「屈折率が高いほど薄い」</span>を直感的に伝える視覚ツール
          </p>
        </div>
        <button id="btnShare" class="hidden sm:inline-flex items-center gap-2 rounded-xl bg-white ring-soft px-3 py-2 text-sm font-medium text-slate-700 hover:bg-slate-50 soft-shadow smooth">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" class="opacity-80">
            <path d="M12 16V4m0 0l-4 4m4-4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M20 16.5c0 1.38-1.12 2.5-2.5 2.5h-11C5.12 19 4 17.88 4 16.5V14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
          この条件を共有
        </button>
      </div>

      <div id="toast" class="pointer-events-none fixed left-1/2 top-4 z-50 hidden -translate-x-1/2 rounded-xl bg-slate-900/90 px-4 py-2 text-sm text-white shadow-lg">
        コピーしました
      </div>
    </header>

    <main class="grid gap-6 lg:grid-cols-2">
      <!-- Controls -->
      <section class="rounded-2xl bg-white p-5 sm:p-6 soft-shadow ring-soft">
        <div class="flex items-center justify-between">
          <h2 class="text-base font-semibold">条件を選ぶ</h2>
          <button id="btnReset" class="rounded-xl px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-50 smooth">
            リセット
          </button>
        </div>

        <!-- SPH -->
        <div class="mt-5">
          <label class="flex items-end justify-between gap-3">
            <span class="text-sm font-medium text-slate-700">度数（SPH）</span>
            <span class="mono-num text-sm font-semibold text-slate-900" id="sphBadge">-4.00 D</span>
          </label>

          <div class="mt-3 grid gap-3">
            <!-- +度数対応: -10.00 ～ +8.00 -->
            <input id="sphRange" type="range" min="-10" max="8" step="0.25" value="-4" aria-label="度数スライダー">
            <div class="flex items-center justify-between text-xs text-slate-500 mono-num">
              <span>-10.00</span><span>-6.00</span><span>-2.00</span><span>+2.00</span><span>+8.00</span>
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <div class="rounded-xl bg-slate-50 p-3 ring-soft">
                <label for="sphSelect" class="block text-xs font-medium text-slate-600">セレクトで選ぶ</label>
                <select id="sphSelect" class="mt-2 w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm focus:outline-none focus:ring-4 focus:ring-slate-200 smooth">
                </select>
                <p class="mt-2 text-xs text-slate-500">※-10.00〜+8.00 を 0.25D 刻み（0.00は除外）</p>
              </div>

              <div class="rounded-xl bg-slate-50 p-3 ring-soft">
                <label class="block text-xs font-medium text-slate-600">接客メモ（任意）</label>
                <input id="memo" type="text" placeholder="例）軽さ優先／薄型希望 など"
                  class="mt-2 w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm focus:outline-none focus:ring-4 focus:ring-slate-200 smooth"/>
                <p class="mt-2 text-xs text-slate-500">共有URLにも含められます</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Index -->
        <div class="mt-6">
          <div class="flex items-end justify-between gap-3">
            <label class="text-sm font-medium text-slate-700" for="idxSelect">屈折率（レンズの薄さ）</label>
            <span class="text-xs text-slate-500">薄さの目安：<span id="idxLabel" class="font-semibold text-slate-700">—</span></span>
          </div>

          <div class="mt-3 grid gap-3">
            <select id="idxSelect" class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm focus:outline-none focus:ring-4 focus:ring-slate-200 smooth"></select>

            <div class="rounded-xl bg-slate-50 p-3 ring-soft">
              <div class="flex items-center justify-between">
                <p class="text-xs font-medium text-slate-600">説明トーク用（ワンタップでコピー）</p>
                <button id="btnCopyTalk" class="rounded-lg bg-white px-2.5 py-1.5 text-xs font-semibold text-slate-700 ring-soft hover:bg-slate-50 smooth">
                  コピー
                </button>
              </div>
              <p id="talkText" class="mt-2 text-sm text-slate-700 leading-relaxed">—</p>
            </div>
          </div>
        </div>

        <!-- Warnings -->
        <div id="warnBox" class="mt-6 hidden rounded-xl border border-amber-200 bg-amber-50 p-3 text-amber-900">
          <p class="text-sm font-medium">入力が不正です</p>
          <p class="mt-1 text-xs opacity-80" id="warnText">—</p>
        </div>

        <div class="mt-6 rounded-xl border border-slate-200 bg-white p-3">
          <p class="text-xs text-slate-500 leading-relaxed">
            ※このアプリは<strong>相対比較</strong>用です（厳密な光学計算ではありません）。<br class="hidden sm:block"/>
            実際の厚みは、レンズ径・PD・フレーム形状・カーブ・設計（非球面等）などで変わります。
          </p>
        </div>
      </section>

      <!-- Visual -->
      <section class="rounded-2xl bg-white p-5 sm:p-6 soft-shadow ring-soft">
        <div class="flex items-center justify-between gap-3">
          <h2 class="text-base font-semibold">見た目で比較（断面イメージ）</h2>
          <div class="flex items-center gap-2">
            <button id="btnToggleCompare" class="rounded-xl bg-slate-900 px-3 py-2 text-sm font-semibold text-white hover:bg-slate-800 smooth">
              5種類を同時比較
            </button>
          </div>
        </div>

        <div class="mt-4 rounded-2xl border border-slate-200 bg-white p-4 sm:p-5">
          <div class="flex flex-wrap items-center justify-between gap-3">
            <div class="text-sm text-slate-700">
              <div class="mono-num font-semibold text-slate-900">
                SPH <span id="readSph">-4.00</span> D
                <span class="mx-2 text-slate-300">|</span>
                屈折率 <span id="readIdx">1.67</span>
              </div>
              <div class="mt-1 text-xs text-slate-500" id="posHint">—</div>
            </div>

            <div class="flex items-center gap-2">
              <span class="inline-flex items-center gap-2 rounded-full bg-slate-50 px-3 py-1 text-xs font-medium text-slate-700 ring-soft">
                <span class="inline-block h-2 w-2 rounded-full bg-slate-900/70"></span>
                厚みスケール
              </span>
              <button id="btnScale" class="rounded-xl bg-slate-50 px-3 py-2 text-xs font-semibold text-slate-700 ring-soft hover:bg-slate-100 smooth">
                見やすく調整
              </button>
            </div>
          </div>

          <!-- Canvas -->
          <div class="mt-4 grid gap-4">
            <div class="rounded-2xl bg-slate-50 p-4 ring-soft grid-dot">
              <div class="flex items-center justify-between">
                <div class="text-xs font-semibold text-slate-700">断面イメージ</div>
                <div class="text-xs text-slate-500 mono-num" id="thicknessReadout">—</div>
              </div>

              <div class="mt-3 flex items-center justify-center">
                <svg id="lensSvg" width="360" height="200" viewBox="0 0 360 200" class="max-w-full">
                  <defs>
                    <linearGradient id="glassGrad" x1="0" x2="0" y1="0" y2="1">
                      <stop offset="0" stop-color="rgba(255,255,255,0.85)" />
                      <stop offset="1" stop-color="rgba(148,163,184,0.25)" />
                    </linearGradient>
                    <filter id="soft" x="-20%" y="-20%" width="140%" height="140%">
                      <feDropShadow dx="0" dy="10" stdDeviation="10" flood-color="rgba(0,0,0,0.15)" />
                    </filter>
                  </defs>

                  <g opacity="0.55">
                    <line x1="30" y1="160" x2="330" y2="160" stroke="rgba(15,23,42,0.18)" stroke-width="2" />
                    <line x1="180" y1="30" x2="180" y2="170" stroke="rgba(15,23,42,0.10)" stroke-width="2" stroke-dasharray="6 6" />
                  </g>

                  <path id="lensPath" d="" fill="url(#glassGrad)" stroke="rgba(15,23,42,0.35)" stroke-width="2" filter="url(#soft)"></path>

                  <g id="labelGroup" class="mono-num">
                    <rect x="24" y="18" rx="10" ry="10" width="210" height="28" fill="rgba(255,255,255,0.85)" stroke="rgba(15,23,42,0.12)"/>
                    <text id="lensLabel" x="38" y="37" font-size="12" fill="rgba(15,23,42,0.75)">—</text>
                  </g>
                </svg>
              </div>

              <div class="mt-3 flex flex-wrap items-center justify-between gap-3 text-xs text-slate-600">
                <div class="flex items-center gap-2">
                  <span class="inline-block h-2.5 w-2.5 rounded-full bg-slate-900/70"></span>
                  <span id="legendText">—</span>
                </div>
                <div class="text-slate-500">※表示は相対</div>
              </div>
            </div>

            <!-- Compare mode -->
            <div id="compareWrap" class="hidden">
              <div class="rounded-2xl border border-slate-200 bg-white p-4">
                <div class="flex items-center justify-between">
                  <p class="text-sm font-semibold text-slate-800">同じ度数で「屈折率別」に並べて比較</p>
                  <p class="text-xs text-slate-500">右ほど薄い</p>
                </div>

                <div id="compareGrid" class="mt-4 grid gap-3 sm:grid-cols-2 lg:grid-cols-3"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="mt-5 rounded-2xl bg-slate-900 p-4 text-white">
          <p class="text-sm font-semibold">接客での使い方</p>
          <ul class="mt-2 space-y-1 text-sm text-white/90">
            <li>・まず度数（SPH）を合わせて、屈折率を切り替えて見せる</li>
            <li>・「同時比較」で差が出る瞬間を見せる（特に強度数）</li>
            <li>・最後に「この条件を共有」でURL送付（自宅で再確認できます）</li>
          </ul>
        </div>
      </section>
    </main>

    <footer class="mt-8 text-center text-xs text-slate-500">
      © Lens Thickness Visualizer (Relative) — single-file demo
    </footer>
  </div>

  <script>
    // -----------------------------
    // Utilities
    // -----------------------------
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    const roundTo = (v, step) => Math.round(v / step) * step;
    const $ = (id) => document.getElementById(id);

    const fmtDiopter = (v) => {
      const n = Number(v);
      if (!Number.isFinite(n)) return "—";
      const s = Math.abs(n).toFixed(2);
      if (n > 0) return "+" + s;
      if (n < 0) return "-" + s;
      return "0.00";
    };

    const toIdxKey = (v) => Number(v).toFixed(2); // "1.60" のように必ず揃える

    const showToast = (msg = "コピーしました") => {
      const t = $("toast");
      t.textContent = msg;
      t.classList.remove("hidden");
      clearTimeout(showToast._timer);
      showToast._timer = setTimeout(() => t.classList.add("hidden"), 1200);
    };

    async function safeCopy(text) {
      try {
        await navigator.clipboard.writeText(text);
        showToast("コピーしました");
        return true;
      } catch (e) {
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.setAttribute("readonly", "");
        ta.style.position = "fixed";
        ta.style.top = "-1000px";
        document.body.appendChild(ta);
        ta.select();
        try {
          document.execCommand("copy");
          showToast("コピーしました");
          document.body.removeChild(ta);
          return true;
        } catch {
          document.body.removeChild(ta);
          showToast("コピーできませんでした");
          return false;
        }
      }
    }

    // -----------------------------
    // State
    // -----------------------------
    const DEFAULT = {
      sph: -4.00,
      idx: "1.67",
      memo: "",
      scaleBoost: 1.00,
      compare: false,
    };

    // ✅ 修正ポイント①：キーを必ず "1.60" 形式の文字列で統一（JSの 1.60 → "1.6" 問題を回避）
    // thinFactor: 数値が小さいほど薄く表示（相対）
    const IDX_META = {
      "1.50": { name: "超標準", thinFactor: 1.12 },
      "1.60": { name: "標準",   thinFactor: 1.00 },
      "1.67": { name: "薄型",   thinFactor: 0.86 },
      "1.74": { name: "超薄型", thinFactor: 0.74 },
      "1.76": { name: "極薄",   thinFactor: 0.71 },
    };

    const IDX_ORDER = ["1.50","1.60","1.67","1.74","1.76"];

    const S = { ...DEFAULT };

    // -----------------------------
    // DOM refs
    // -----------------------------
    const sphRange = $("sphRange");
    const sphSelect = $("sphSelect");
    const sphBadge = $("sphBadge");
    const idxSelect = $("idxSelect");
    const idxLabel = $("idxLabel");
    const memo = $("memo");

    const readSph = $("readSph");
    const readIdx = $("readIdx");
    const thicknessReadout = $("thicknessReadout");
    const posHint = $("posHint");
    const legendText = $("legendText");

    const warnBox = $("warnBox");
    const warnText = $("warnText");

    const lensPath = $("lensPath");
    const lensLabel = $("lensLabel");

    const btnReset = $("btnReset");
    const btnScale = $("btnScale");
    const btnToggleCompare = $("btnToggleCompare");
    const compareWrap = $("compareWrap");
    const compareGrid = $("compareGrid");

    const btnShare = $("btnShare");
    const btnCopyTalk = $("btnCopyTalk");
    const talkText = $("talkText");

    // -----------------------------
    // Build select options
    // -----------------------------
    function buildSphOptions() {
      // -10.00 ～ +8.00 / 0.25 step, 0.00 は除外
      const min = -10.00, max = 8.00, step = 0.25;
      const opts = [];
      for (let v = max; v >= min; v = Math.round((v - step) * 100) / 100) {
        if (Math.abs(v) < 0.001) continue; // 0.00除外（接客でほぼ不要＆誤解防止）
        opts.push(v);
      }
      sphSelect.innerHTML = opts.map(v => `<option value="${v.toFixed(2)}">${fmtDiopter(v)} D</option>`).join("");
    }

    function buildIdxOptions() {
      idxSelect.innerHTML = IDX_ORDER.map(k => {
        const m = IDX_META[k];
        return `<option value="${k}">${k}（${m.name}）</option>`;
      }).join("");
    }

    // -----------------------------
    // Relative thickness model (not real optics)
    // -----------------------------
    function calcThicknessScore(sph, idxKey) {
      // abs: 0..10 くらい（0は除外）
      const abs = Math.abs(Number(sph));
      const meta = IDX_META[idxKey] || IDX_META["1.60"];

      // 強度数ほど差が見えやすいようにカーブ強め
      const norm = clamp((abs - 1) / (10 - 1), 0, 1); // 0..1 (abs=1で0)
      const base = Math.pow(norm, 1.18);              // 0..1
      const withMin = 0.18 + base * 0.82;             // 0.18..1.00

      const score = withMin * meta.thinFactor;        // 屈折率で薄く
      return clamp(score, 0.10, 1.25);
    }

    function scoreToBulge(score) {
      // 0.10..1.25 → 10..66 の表示量（scaleBoostで調整）
      const b = 10 + (score - 0.10) / (1.25 - 0.10) * (66 - 10);
      return clamp(b, 8, 90) * S.scaleBoost;
    }

    // -----------------------------
    // SVG path builder
    // 近視(マイナス): 端が厚い（外側がふくらむ）
    // 遠視(プラス): 中心が厚い（中心がふくらむ）
    // -----------------------------
    function buildLensPathForMinus(edgeBulge) {
      const cx = 180, top = 55, bottom = 155;
      const left = 55, right = 305;
      const midY = (top + bottom) / 2;

      const out = clamp(edgeBulge, 8, 90);
      const c1x = cx - 70, c2x = cx + 70;

      return [
        `M ${left} ${midY}`,
        `C ${left} ${midY - out} ${c1x} ${top} ${cx} ${top + 8}`,
        `C ${c2x} ${top} ${right} ${midY - out} ${right} ${midY}`,
        `C ${right} ${midY + out} ${c2x} ${bottom} ${cx} ${bottom - 8}`,
        `C ${c1x} ${bottom} ${left} ${midY + out} ${left} ${midY}`,
        "Z"
      ].join(" ");
    }

    function buildLensPathForPlus(centerBulge) {
      // 中心が厚い＝中央がふくらむ（端は比較的薄い）
      const cx = 180, top = 60, bottom = 150;
      const left = 60, right = 300;
      const midY = (top + bottom) / 2;

      const c = clamp(centerBulge, 8, 90);
      const edge = 10; // 端は薄めに固定（見た目の分かりやすさ優先）

      // 中央で上にせり出す（top - c）、下も同様
      const peakTopY = top - c * 0.55;
      const peakBotY = bottom + c * 0.55;

      const c1x = cx - 80, c2x = cx + 80;

      return [
        `M ${left} ${midY}`,
        // 上側：端は薄く、中央が厚い
        `C ${left} ${midY - edge} ${c1x} ${peakTopY} ${cx} ${top + 6}`,
        `C ${c2x} ${peakTopY} ${right} ${midY - edge} ${right} ${midY}`,
        // 下側
        `C ${right} ${midY + edge} ${c2x} ${peakBotY} ${cx} ${bottom - 6}`,
        `C ${c1x} ${peakBotY} ${left} ${midY + edge} ${left} ${midY}`,
        "Z"
      ].join(" ");
    }

    // -----------------------------
    // Text helpers
    // -----------------------------
    function getThicknessPositionHint(sph) {
      if (sph < 0) return "“端が厚く”なる近視（−）のイメージ（中心厚は一定扱い）";
      return "“中心が厚く”なる遠視（＋）のイメージ（端厚は薄め扱い）";
    }

    function getLegend(sph) {
      if (sph < 0) return "近視（−）：端のふくらみが大きいほど“端が厚い”表示";
      return "遠視（＋）：中心のふくらみが大きいほど“中心が厚い”表示";
    }

    function updateTalkText() {
      const idxKey = toIdxKey(S.idx);
      const meta = IDX_META[idxKey] || IDX_META["1.60"];
      const sph = Number(S.sph);

      const base = calcThicknessScore(sph, "1.60");
      const cur = calcThicknessScore(sph, idxKey);
      const relPct = (cur / base) * 100;

      const where = sph < 0 ? "端の厚み" : "中心の厚み";
      const memoPart = S.memo.trim() ? `（メモ：${S.memo.trim()}）` : "";

      talkText.textContent =
        `度数 ${fmtDiopter(sph)}D の場合、屈折率 ${idxKey}（${meta.name}）は、標準(1.60)に比べて${where}イメージが約 ${relPct.toFixed(0)}% になります。` +
        `（相対表示）${memoPart}`;
    }

    // -----------------------------
    // Validation
    // -----------------------------
    function validateState() {
      const sph = Number(S.sph);
      const idxKey = toIdxKey(S.idx);

      const okSph = Number.isFinite(sph) && sph >= -10 && sph <= 8 && Math.abs(sph) > 0.001;
      const okIdx = !!IDX_META[idxKey];

      if (!okSph || !okIdx) {
        warnBox.classList.remove("hidden");
        warnText.textContent = !okSph
          ? "度数（SPH）が範囲外です（-10.00〜+8.00、0.00は除外）。"
          : "屈折率が不正です。";
        return false;
      }
      warnBox.classList.add("hidden");
      return true;
    }

    // -----------------------------
    // Rendering
    // -----------------------------
    function renderSingle() {
      if (!validateState()) return;

      const sph = Number(S.sph);
      const idxKey = toIdxKey(S.idx);
      const meta = IDX_META[idxKey] || IDX_META["1.60"];

      sphBadge.textContent = `${fmtDiopter(sph)} D`;
      readSph.textContent = fmtDiopter(sph);
      readIdx.textContent = idxKey;
      idxLabel.textContent = `${idxKey} ${meta.name}`.trim();

      posHint.textContent = getThicknessPositionHint(sph);
      legendText.textContent = getLegend(sph);

      const score = calcThicknessScore(sph, idxKey);
      const bulge = scoreToBulge(score);

      // +/−で断面表示を切替
      const path = (sph < 0) ? buildLensPathForMinus(bulge) : buildLensPathForPlus(bulge);
      lensPath.setAttribute("d", path);

      // 擬似mm表示（位置に合わせて文言変更）
      const pseudoMm = (2.0 + score * 6.2); // ざっくり 2〜10mmレンジ
      const where = sph < 0 ? "端" : "中心";
      thicknessReadout.textContent = `${where}の厚み目安：${pseudoMm.toFixed(1)} mm（相対）`;

      lensLabel.textContent = `SPH ${fmtDiopter(sph)}D  /  屈折率 ${idxKey}`;

      updateTalkText();
    }

    function renderCompare() {
      compareGrid.innerHTML = "";
      const sph = Number(S.sph);

      const baseScore = calcThicknessScore(sph, "1.60");

      IDX_ORDER.forEach((idxKey) => {
        const meta = IDX_META[idxKey];
        const score = calcThicknessScore(sph, idxKey);
        const bulge = scoreToBulge(score);
        const rel = (score / baseScore) * 100;

        const path = (sph < 0) ? buildLensPathForMinus(bulge) : buildLensPathForPlus(bulge);
        const where = sph < 0 ? "端" : "中心";

        const card = document.createElement("div");
        card.className = "rounded-2xl bg-slate-50 p-3 ring-soft";
        card.innerHTML = `
          <div class="flex items-center justify-between">
            <div class="text-sm font-semibold text-slate-800">${idxKey} <span class="text-xs font-medium text-slate-500">(${meta.name})</span></div>
            <div class="text-xs text-slate-500 mono-num">${rel.toFixed(0)}%</div>
          </div>
          <div class="mt-2 flex items-center justify-center">
            <svg width="240" height="120" viewBox="0 0 360 200" class="max-w-full">
              <defs>
                <linearGradient id="g-${idxKey.replace(".","")}" x1="0" x2="0" y1="0" y2="1">
                  <stop offset="0" stop-color="rgba(255,255,255,0.85)" />
                  <stop offset="1" stop-color="rgba(148,163,184,0.22)" />
                </linearGradient>
              </defs>
              <path d="${path}" fill="url(#g-${idxKey.replace(".","")})" stroke="rgba(15,23,42,0.35)" stroke-width="2"></path>
            </svg>
          </div>
          <div class="mt-2 text-xs text-slate-600">${where}の厚みイメージが標準比 <span class="mono-num font-semibold text-slate-800">${rel.toFixed(0)}%</span></div>
        `;
        compareGrid.appendChild(card);
      });
    }

    function setCompareMode(on) {
      S.compare = !!on;
      compareWrap.classList.toggle("hidden", !S.compare);
      btnToggleCompare.textContent = S.compare ? "比較を閉じる" : "5種類を同時比較";
      if (S.compare) renderCompare();
    }

    function syncUIFromState() {
      // 0.00だけは避ける
      if (Math.abs(Number(S.sph)) < 0.001) S.sph = -0.25;

      sphRange.value = Number(S.sph).toFixed(2);
      sphSelect.value = Number(S.sph).toFixed(2);
      idxSelect.value = toIdxKey(S.idx);
      memo.value = S.memo || "";

      renderSingle();
      if (S.compare) renderCompare();
    }

    // -----------------------------
    // URL state (share)
    // -----------------------------
    function stateToQuery() {
      const p = new URLSearchParams();
      p.set("sph", Number(S.sph).toFixed(2));
      p.set("idx", toIdxKey(S.idx));
      if ((S.memo || "").trim()) p.set("memo", (S.memo || "").trim().slice(0, 60));
      if (S.scaleBoost !== 1.0) p.set("scale", S.scaleBoost.toFixed(2));
      if (S.compare) p.set("cmp", "1");
      return p.toString();
    }

    function applyQueryToState() {
      const p = new URLSearchParams(location.search);

      const sph = Number(p.get("sph"));
      const idx = p.get("idx");
      const memoQ = p.get("memo");
      const scale = Number(p.get("scale"));
      const cmp = p.get("cmp") === "1";

      if (Number.isFinite(sph)) {
        const v = clamp(roundTo(sph, 0.25), -10, 8);
        S.sph = (Math.abs(v) < 0.001) ? -0.25 : v;
      }
      if (typeof idx === "string") {
        const k = toIdxKey(idx);
        if (IDX_META[k]) S.idx = k;
      }
      if (typeof memoQ === "string") S.memo = memoQ.slice(0, 60);
      if (Number.isFinite(scale)) S.scaleBoost = clamp(scale, 0.85, 1.35);
      S.compare = cmp;
    }

    function buildShareUrl() {
      const qs = stateToQuery();
      const url = new URL(location.href);
      url.search = qs;
      return url.toString();
    }

    async function shareCurrent() {
      const url = buildShareUrl();
      const title = "レンズ厚み比較（相対）";
      const text = `SPH ${fmtDiopter(S.sph)}D / 屈折率 ${toIdxKey(S.idx)} の比較URLです。`;

      if (navigator.share) {
        try { await navigator.share({ title, text, url }); return; } catch {}
      }
      await safeCopy(url);
    }

    // -----------------------------
    // Events
    // -----------------------------
    function onSphChange(v) {
      const num = Number(v);
      if (!Number.isFinite(num)) return;
      let next = clamp(roundTo(num, 0.25), -10, 8);
      if (Math.abs(next) < 0.001) next = (S.sph < 0 ? -0.25 : 0.25);
      S.sph = next;
      syncUIFromState();
      history.replaceState(null, "", "?" + stateToQuery());
    }

    function onIdxChange(v) {
      const k = toIdxKey(v);
      if (!IDX_META[k]) return;
      S.idx = k;
      syncUIFromState();
      history.replaceState(null, "", "?" + stateToQuery());
    }

    function onMemoChange(v) {
      S.memo = (v || "").slice(0, 60);
      updateTalkText();
      history.replaceState(null, "", "?" + stateToQuery());
    }

    function onScaleToggle() {
      const levels = [1.00, 1.18, 1.35];
      const idx = levels.findIndex(x => Math.abs(x - S.scaleBoost) < 0.02);
      S.scaleBoost = levels[(idx + 1) % levels.length];
      btnScale.textContent = S.scaleBoost === 1.00 ? "見やすく調整" : `表示倍率 x${S.scaleBoost.toFixed(2)}`;
      syncUIFromState();
      history.replaceState(null, "", "?" + stateToQuery());
    }

    function resetAll() {
      Object.assign(S, DEFAULT);
      setCompareMode(false);
      btnScale.textContent = "見やすく調整";
      syncUIFromState();
      history.replaceState(null, "", location.pathname);
    }

    // -----------------------------
    // Init
    // -----------------------------
    buildSphOptions();
    buildIdxOptions();

    applyQueryToState();
    // 初期選択を合わせる
    sphRange.value = Number(S.sph).toFixed(2);
    sphSelect.value = Number(S.sph).toFixed(2);
    idxSelect.value = toIdxKey(S.idx);

    syncUIFromState();
    setCompareMode(S.compare);

    btnScale.textContent = S.scaleBoost === 1.00 ? "見やすく調整" : `表示倍率 x${S.scaleBoost.toFixed(2)}`;

    sphRange.addEventListener("input", (e) => onSphChange(e.target.value));
    sphSelect.addEventListener("change", (e) => onSphChange(e.target.value));
    idxSelect.addEventListener("change", (e) => onIdxChange(e.target.value));
    memo.addEventListener("input", (e) => onMemoChange(e.target.value));

    btnReset.addEventListener("click", resetAll);
    btnScale.addEventListener("click", onScaleToggle);

    btnToggleCompare.addEventListener("click", () => {
      setCompareMode(!S.compare);
      history.replaceState(null, "", "?" + stateToQuery());
    });

    btnShare.addEventListener("click", shareCurrent);

    btnCopyTalk.addEventListener("click", async () => {
      await safeCopy(talkText.textContent.trim());
    });

    window.addEventListener("resize", () => {
      if (S.compare) renderCompare();
    });
  </script>
</body>
</html>
