<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>レンズの厚み（薄さ）比較シミュレーター｜眼鏡店向け</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* ほんの少しだけ“アプリ感”を上げるための細部 */
    .soft-shadow { box-shadow: 0 10px 30px rgba(0,0,0,.06); }
    .ring-soft { box-shadow: 0 0 0 1px rgba(15,23,42,.08) inset; }
    .grid-dot {
      background-image: radial-gradient(rgba(15,23,42,.08) 1px, transparent 1px);
      background-size: 14px 14px;
      background-position: 0 0;
    }
    /* iOSのrange見た目を安定 */
    input[type="range"] { -webkit-appearance: none; appearance: none; height: 6px; border-radius: 999px; background: rgba(15,23,42,.12); outline: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 999px; background: white; border: 1px solid rgba(15,23,42,.18); box-shadow: 0 6px 18px rgba(0,0,0,.12); }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 999px; background: white; border: 1px solid rgba(15,23,42,.18); box-shadow: 0 6px 18px rgba(0,0,0,.12); }
    /* アニメーション */
    .smooth { transition: all .22s ease; }
    .mono-num { font-variant-numeric: tabular-nums; }
  </style>
</head>

<body class="min-h-screen bg-slate-50 text-slate-900">
  <div class="mx-auto max-w-5xl px-4 py-6 sm:py-10">
    <!-- Header -->
    <header class="mb-6 sm:mb-8">
      <div class="flex items-start justify-between gap-4">
        <div>
          <h1 class="text-xl sm:text-2xl font-semibold tracking-tight">
            レンズの厚み（薄さ）比較シミュレーター
          </h1>
          <p class="mt-1 text-sm sm:text-base text-slate-600">
            厳密計算ではなく、<span class="font-medium text-slate-700">「度数が強いほど厚く」「屈折率が高いほど薄い」</span>を直感的に伝える視覚ツール
          </p>
        </div>
        <button id="btnShare" class="hidden sm:inline-flex items-center gap-2 rounded-xl bg-white ring-soft px-3 py-2 text-sm font-medium text-slate-700 hover:bg-slate-50 soft-shadow smooth">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" class="opacity-80">
            <path d="M12 16V4m0 0l-4 4m4-4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M20 16.5c0 1.38-1.12 2.5-2.5 2.5h-11C5.12 19 4 17.88 4 16.5V14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
          この条件を共有
        </button>
      </div>

      <div id="toast" class="pointer-events-none fixed left-1/2 top-4 z-50 hidden -translate-x-1/2 rounded-xl bg-slate-900/90 px-4 py-2 text-sm text-white shadow-lg">
        コピーしました
      </div>
    </header>

    <main class="grid gap-6 lg:grid-cols-2">
      <!-- Controls -->
      <section class="rounded-2xl bg-white p-5 sm:p-6 soft-shadow ring-soft">
        <div class="flex items-center justify-between">
          <h2 class="text-base font-semibold">条件を選ぶ</h2>
          <button id="btnReset" class="rounded-xl px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-50 smooth">
            リセット
          </button>
        </div>

        <!-- SPH -->
        <div class="mt-5">
          <label class="flex items-end justify-between gap-3">
            <span class="text-sm font-medium text-slate-700">度数（SPH / 近視のマイナス）</span>
            <span class="mono-num text-sm font-semibold text-slate-900" id="sphBadge">-4.00 D</span>
          </label>

          <div class="mt-3 grid gap-3">
            <input id="sphRange" type="range" min="-10" max="-2" step="0.25" value="-4" aria-label="度数スライダー">
            <div class="flex items-center justify-between text-xs text-slate-500 mono-num">
              <span>-10.00</span><span>-8.00</span><span>-6.00</span><span>-4.00</span><span>-2.00</span>
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <div class="rounded-xl bg-slate-50 p-3 ring-soft">
                <label for="sphSelect" class="block text-xs font-medium text-slate-600">セレクトで選ぶ</label>
                <select id="sphSelect" class="mt-2 w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm focus:outline-none focus:ring-4 focus:ring-slate-200 smooth">
                </select>
                <p class="mt-2 text-xs text-slate-500">※-2.00〜-10.00 を 0.25D 刻み</p>
              </div>

              <div class="rounded-xl bg-slate-50 p-3 ring-soft">
                <label class="block text-xs font-medium text-slate-600">接客メモ（任意）</label>
                <input id="memo" type="text" placeholder="例）軽さ優先／薄型希望 など"
                  class="mt-2 w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm focus:outline-none focus:ring-4 focus:ring-slate-200 smooth"/>
                <p class="mt-2 text-xs text-slate-500">共有URLにも含められます</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Index -->
        <div class="mt-6">
          <div class="flex items-end justify-between gap-3">
            <label class="text-sm font-medium text-slate-700" for="idxSelect">屈折率（レンズの薄さ）</label>
            <span class="text-xs text-slate-500">薄さの目安：<span id="idxLabel" class="font-semibold text-slate-700">1.67 薄型</span></span>
          </div>

          <div class="mt-3 grid gap-3">
            <select id="idxSelect" class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm focus:outline-none focus:ring-4 focus:ring-slate-200 smooth">
              <option value="1.60" data-name="標準">1.60（標準）</option>
              <option value="1.67" data-name="薄型" selected>1.67（薄型）</option>
              <option value="1.74" data-name="超薄型">1.74（超薄型）</option>
            </select>

            <div class="rounded-xl bg-slate-50 p-3 ring-soft">
              <div class="flex items-center justify-between">
                <p class="text-xs font-medium text-slate-600">説明トーク用（ワンタップでコピー）</p>
                <button id="btnCopyTalk" class="rounded-lg bg-white px-2.5 py-1.5 text-xs font-semibold text-slate-700 ring-soft hover:bg-slate-50 smooth">
                  コピー
                </button>
              </div>
              <p id="talkText" class="mt-2 text-sm text-slate-700 leading-relaxed">
                —
              </p>
            </div>
          </div>
        </div>

        <!-- Warnings -->
        <div id="warnBox" class="mt-6 hidden rounded-xl border border-amber-200 bg-amber-50 p-3 text-amber-900">
          <p class="text-sm font-medium">入力が不正です</p>
          <p class="mt-1 text-xs opacity-80" id="warnText">—</p>
        </div>

        <div class="mt-6 rounded-xl border border-slate-200 bg-white p-3">
          <p class="text-xs text-slate-500 leading-relaxed">
            ※このアプリは<strong>相対比較</strong>用です（厳密な光学計算ではありません）。<br class="hidden sm:block"/>
            実際の厚みは、レンズ径・PD・フレーム形状・カーブ・設計（非球面等）などで変わります。
          </p>
        </div>
      </section>

      <!-- Visual -->
      <section class="rounded-2xl bg-white p-5 sm:p-6 soft-shadow ring-soft">
        <div class="flex items-center justify-between gap-3">
          <h2 class="text-base font-semibold">見た目で比較（断面イメージ）</h2>
          <div class="flex items-center gap-2">
            <button id="btnToggleCompare" class="rounded-xl bg-slate-900 px-3 py-2 text-sm font-semibold text-white hover:bg-slate-800 smooth">
              3種類を同時比較
            </button>
          </div>
        </div>

        <div class="mt-4 rounded-2xl border border-slate-200 bg-white p-4 sm:p-5">
          <div class="flex flex-wrap items-center justify-between gap-3">
            <div class="text-sm text-slate-700">
              <div class="mono-num font-semibold text-slate-900">
                SPH <span id="readSph">-4.00</span> D
                <span class="mx-2 text-slate-300">|</span>
                屈折率 <span id="readIdx">1.67</span>
              </div>
              <div class="mt-1 text-xs text-slate-500">“端の厚み” のイメージ（中心厚は一定扱い）</div>
            </div>

            <div class="flex items-center gap-2">
              <span class="inline-flex items-center gap-2 rounded-full bg-slate-50 px-3 py-1 text-xs font-medium text-slate-700 ring-soft">
                <span class="inline-block h-2 w-2 rounded-full bg-slate-900/70"></span>
                厚みスケール
              </span>
              <button id="btnScale" class="rounded-xl bg-slate-50 px-3 py-2 text-xs font-semibold text-slate-700 ring-soft hover:bg-slate-100 smooth">
                見やすく調整
              </button>
            </div>
          </div>

          <!-- Canvas -->
          <div class="mt-4 grid gap-4">
            <div class="rounded-2xl bg-slate-50 p-4 ring-soft grid-dot">
              <div class="flex items-center justify-between">
                <div class="text-xs font-semibold text-slate-700">断面イメージ</div>
                <div class="text-xs text-slate-500 mono-num" id="thicknessReadout">端の厚み目安：—</div>
              </div>

              <div class="mt-3 flex items-center justify-center">
                <svg id="lensSvg" width="360" height="200" viewBox="0 0 360 200" class="max-w-full">
                  <!-- 背景ガイド -->
                  <defs>
                    <linearGradient id="glassGrad" x1="0" x2="0" y1="0" y2="1">
                      <stop offset="0" stop-color="rgba(255,255,255,0.85)" />
                      <stop offset="1" stop-color="rgba(148,163,184,0.25)" />
                    </linearGradient>
                    <filter id="soft" x="-20%" y="-20%" width="140%" height="140%">
                      <feDropShadow dx="0" dy="10" stdDeviation="10" flood-color="rgba(0,0,0,0.15)" />
                    </filter>
                  </defs>

                  <g opacity="0.55">
                    <line x1="30" y1="160" x2="330" y2="160" stroke="rgba(15,23,42,0.18)" stroke-width="2" />
                    <line x1="180" y1="30" x2="180" y2="170" stroke="rgba(15,23,42,0.10)" stroke-width="2" stroke-dasharray="6 6" />
                  </g>

                  <!-- レンズ本体 -->
                  <path id="lensPath" d="" fill="url(#glassGrad)" stroke="rgba(15,23,42,0.35)" stroke-width="2" filter="url(#soft)"></path>

                  <!-- ラベル -->
                  <g id="labelGroup" class="mono-num">
                    <rect x="24" y="18" rx="10" ry="10" width="170" height="28" fill="rgba(255,255,255,0.85)" stroke="rgba(15,23,42,0.12)"/>
                    <text id="lensLabel" x="38" y="37" font-size="12" fill="rgba(15,23,42,0.75)">—</text>
                  </g>
                </svg>
              </div>

              <!-- Legend -->
              <div class="mt-3 flex flex-wrap items-center justify-between gap-3 text-xs text-slate-600">
                <div class="flex items-center gap-2">
                  <span class="inline-block h-2.5 w-2.5 rounded-full bg-slate-900/70"></span>
                  <span>端が厚いほど、外側のふくらみが大きく表示されます</span>
                </div>
                <div class="text-slate-500">※表示は相対</div>
              </div>
            </div>

            <!-- Compare mode -->
            <div id="compareWrap" class="hidden">
              <div class="rounded-2xl border border-slate-200 bg-white p-4">
                <div class="flex items-center justify-between">
                  <p class="text-sm font-semibold text-slate-800">同じ度数で「屈折率別」に並べて比較</p>
                  <p class="text-xs text-slate-500">右ほど薄い</p>
                </div>

                <div id="compareGrid" class="mt-4 grid gap-3 sm:grid-cols-3"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Quick tips -->
        <div class="mt-5 rounded-2xl bg-slate-900 p-4 text-white">
          <p class="text-sm font-semibold">接客での使い方</p>
          <ul class="mt-2 space-y-1 text-sm text-white/90">
            <li>・まず度数（SPH）を合わせて、屈折率を切り替えて見せる</li>
            <li>・「3種類を同時比較」で、差が出る瞬間を見せる</li>
            <li>・最後に「この条件を共有」でお客様にURL送付（自宅で再確認できます）</li>
          </ul>
        </div>
      </section>
    </main>

    <footer class="mt-8 text-center text-xs text-slate-500">
      © Lens Thickness Visualizer (Relative) — single-file demo
    </footer>
  </div>

  <script>
    // -----------------------------
    // Utilities
    // -----------------------------
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    const roundTo = (v, step) => Math.round(v / step) * step;

    const fmtDiopter = (v) => {
      const n = Number(v);
      if (!Number.isFinite(n)) return "—";
      const s = n.toFixed(2);
      return (n > 0 ? "+" : "") + s;
    };

    const $ = (id) => document.getElementById(id);

    const showToast = (msg = "コピーしました") => {
      const t = $("toast");
      t.textContent = msg;
      t.classList.remove("hidden");
      clearTimeout(showToast._timer);
      showToast._timer = setTimeout(() => t.classList.add("hidden"), 1200);
    };

    async function safeCopy(text) {
      try {
        await navigator.clipboard.writeText(text);
        showToast("コピーしました");
        return true;
      } catch (e) {
        // フォールバック：選択してコピーを促す
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.setAttribute("readonly", "");
        ta.style.position = "fixed";
        ta.style.top = "-1000px";
        document.body.appendChild(ta);
        ta.select();
        try {
          document.execCommand("copy");
          showToast("コピーしました");
          document.body.removeChild(ta);
          return true;
        } catch {
          document.body.removeChild(ta);
          showToast("コピーできませんでした");
          return false;
        }
      }
    }

    // -----------------------------
    // State
    // -----------------------------
    const DEFAULT = {
      sph: -4.00,
      idx: 1.67,
      memo: "",
      scaleBoost: 1.00, // 見やすさ調整（表示倍率）
      compare: false,
    };

    const IDX_META = {
      1.60: { name: "標準", thinFactor: 1.00 },
      1.67: { name: "薄型", thinFactor: 0.85 },
      1.74: { name: "超薄型", thinFactor: 0.72 },
    };

    const S = { ...DEFAULT };

    // -----------------------------
    // DOM refs
    // -----------------------------
    const sphRange = $("sphRange");
    const sphSelect = $("sphSelect");
    const sphBadge = $("sphBadge");
    const idxSelect = $("idxSelect");
    const idxLabel = $("idxLabel");
    const memo = $("memo");

    const readSph = $("readSph");
    const readIdx = $("readIdx");
    const thicknessReadout = $("thicknessReadout");

    const warnBox = $("warnBox");
    const warnText = $("warnText");

    const lensPath = $("lensPath");
    const lensLabel = $("lensLabel");

    const btnReset = $("btnReset");
    const btnScale = $("btnScale");
    const btnToggleCompare = $("btnToggleCompare");
    const compareWrap = $("compareWrap");
    const compareGrid = $("compareGrid");

    const btnShare = $("btnShare");
    const btnCopyTalk = $("btnCopyTalk");
    const talkText = $("talkText");

    // -----------------------------
    // Build select options for SPH
    // -----------------------------
    function buildSphOptions() {
      const min = -10.00, max = -2.00, step = 0.25;
      const opts = [];
      for (let v = max; v >= min; v = Math.round((v - step) * 100) / 100) {
        opts.push(v);
      }
      sphSelect.innerHTML = opts.map(v => `<option value="${v.toFixed(2)}">${fmtDiopter(v)} D</option>`).join("");
    }

    // -----------------------------
    // Relative thickness model (not real optics)
    // - stronger minus => thicker edge
    // - higher index => thinner (multiply by thinFactor)
    // -----------------------------
    function calcEdgeThicknessScore(sph, idx) {
      const abs = Math.abs(sph); // 2..10
      const meta = IDX_META[idx] || IDX_META[1.67];
      // Base curve: emphasize higher powers a bit more than linear
      const base = Math.pow((abs - 2) / (10 - 2), 1.15); // 0..1
      const withMin = 0.18 + base * 0.82; // keep visible at low power
      const score = withMin * meta.thinFactor;
      return clamp(score, 0.10, 1.00);
    }

    // Map thickness score to a “visual bulge” (px in SVG coords)
    function scoreToBulge(score) {
      // score 0.10..1.00 -> bulge 10..58 (then scaleBoost)
      const b = 10 + (score - 0.10) / (1.00 - 0.10) * (58 - 10);
      return b * S.scaleBoost;
    }

    // Build lens cross-section path
    // We'll draw a symmetric shape around centerline with thicker edges by increasing outer curvature.
    function buildLensPath(bulge) {
      const cx = 180, top = 55, bottom = 155;
      const left = 55, right = 305;
      const midY = (top + bottom) / 2;

      // "bulge" affects how far outward the edges swell
      const out = clamp(bulge, 8, 85);

      // Control points to make a concave-ish lens center and thick edges
      // (Not physically correct — just visually intuitive)
      const c1x = cx - 70, c2x = cx + 70;

      // Top curve: from left to right
      const d = [
        `M ${left} ${midY}`,
        // upper-left edge
        `C ${left} ${midY - out} ${c1x} ${top} ${cx} ${top + 8}`,
        // upper-right edge
        `C ${c2x} ${top} ${right} ${midY - out} ${right} ${midY}`,
        // lower-right edge
        `C ${right} ${midY + out} ${c2x} ${bottom} ${cx} ${bottom - 8}`,
        // lower-left edge
        `C ${c1x} ${bottom} ${left} ${midY + out} ${left} ${midY}`,
        "Z"
      ].join(" ");
      return d;
    }

    function updateTalkText() {
      const idx = Number(S.idx).toFixed(2);
      const name = (IDX_META[idx]?.name) || "—";
      const sph = fmtDiopter(S.sph);
      const rel = (calcEdgeThicknessScore(S.sph, idx) / calcEdgeThicknessScore(S.sph, 1.60) * 100);
      const relPct = clamp(rel, 55, 100).toFixed(0); // 1.74あたりが55%程度になる想定
      const memoPart = S.memo.trim() ? `（メモ：${S.memo.trim()}）` : "";

      talkText.textContent =
        `度数 ${sph}D の場合、屈折率 ${idx}（${name}）は、標準(1.60)に比べて端の厚みイメージが約 ${relPct}% になります。` +
        ` 見た目の「厚い/薄い」の差を掴むための相対表示です。${memoPart}`;
    }

    function validateState() {
      const sph = Number(S.sph);
      const idx = Number(S.idx);

      const okSph = Number.isFinite(sph) && sph <= -2 && sph >= -10;
      const okIdx = Number.isFinite(idx) && [1.60, 1.67, 1.74].includes(Number(idx.toFixed(2)));

      if (!okSph || !okIdx) {
        warnBox.classList.remove("hidden");
        warnText.textContent = !okSph
          ? "度数（SPH）が範囲外です（-2.00〜-10.00）。"
          : "屈折率が不正です（1.60 / 1.67 / 1.74）。";
        return false;
      }
      warnBox.classList.add("hidden");
      return true;
    }

    function renderSingle() {
      if (!validateState()) return;

      const idx = Number(S.idx).toFixed(2);
      const sph = Number(S.sph);

      sphBadge.textContent = `${fmtDiopter(sph)} D`;
      readSph.textContent = fmtDiopter(sph);
      readIdx.textContent = idx;
      idxLabel.textContent = `${idx} ${IDX_META[idx]?.name || ""}`.trim();

      const score = calcEdgeThicknessScore(sph, idx);
      const bulge = scoreToBulge(score);
      lensPath.setAttribute("d", buildLensPath(bulge));

      // “端の厚み目安”は相対スコアを擬似mmに変換（説明用途のため丸め）
      const pseudoMm = (2.2 + score * 5.8); // だいたい 2.8〜8.0mm っぽいレンジ
      thicknessReadout.textContent = `端の厚み目安：${pseudoMm.toFixed(1)} mm（相対）`;

      lensLabel.textContent = `SPH ${fmtDiopter(sph)}D  /  屈折率 ${idx}`;

      updateTalkText();
      updateShareButtonVisibility();
    }

    function renderCompare() {
      compareGrid.innerHTML = "";
      const sph = Number(S.sph);
      const idxs = [1.60, 1.67, 1.74];

      const baseScore = calcEdgeThicknessScore(sph, 1.60);

      idxs.forEach((ix) => {
        const idx = Number(ix).toFixed(2);
        const score = calcEdgeThicknessScore(sph, ix);
        const bulge = scoreToBulge(score);
        const rel = (score / baseScore) * 100;

        const card = document.createElement("div");
        card.className = "rounded-2xl bg-slate-50 p-3 ring-soft";
        card.innerHTML = `
          <div class="flex items-center justify-between">
            <div class="text-sm font-semibold text-slate-800">${idx} <span class="text-xs font-medium text-slate-500">(${IDX_META[idx].name})</span></div>
            <div class="text-xs text-slate-500 mono-num">${rel.toFixed(0)}%</div>
          </div>
          <div class="mt-2 flex items-center justify-center">
            <svg width="240" height="120" viewBox="0 0 360 200" class="max-w-full">
              <defs>
                <linearGradient id="g-${idx.replace(".","")}" x1="0" x2="0" y1="0" y2="1">
                  <stop offset="0" stop-color="rgba(255,255,255,0.85)" />
                  <stop offset="1" stop-color="rgba(148,163,184,0.22)" />
                </linearGradient>
              </defs>
              <path d="${buildLensPath(bulge)}" fill="url(#g-${idx.replace(".","")})" stroke="rgba(15,23,42,0.35)" stroke-width="2"></path>
            </svg>
          </div>
          <div class="mt-2 text-xs text-slate-600">端の厚みイメージが標準比 <span class="mono-num font-semibold text-slate-800">${rel.toFixed(0)}%</span></div>
        `;
        compareGrid.appendChild(card);
      });
    }

    function setCompareMode(on) {
      S.compare = !!on;
      compareWrap.classList.toggle("hidden", !S.compare);
      btnToggleCompare.textContent = S.compare ? "比較を閉じる" : "3種類を同時比較";
      btnToggleCompare.classList.toggle("bg-slate-900", !S.compare ? true : true);
      if (S.compare) renderCompare();
    }

    function updateShareButtonVisibility() {
      // shareは対応ブラウザ以外でもURLコピーできるため表示は常にOK、
      // ただし狭い画面では上のボタンが無いので、下のトークコピーを使ってもらう想定
      // →ここでは何もしない（将来拡張用）
    }

    function syncUIFromState() {
      sphRange.value = Number(S.sph).toFixed(2);
      sphSelect.value = Number(S.sph).toFixed(2);
      idxSelect.value = Number(S.idx).toFixed(2);
      memo.value = S.memo || "";
      renderSingle();
      if (S.compare) renderCompare();
    }

    // -----------------------------
    // URL state (share)
    // -----------------------------
    function stateToQuery() {
      const p = new URLSearchParams();
      p.set("sph", Number(S.sph).toFixed(2));
      p.set("idx", Number(S.idx).toFixed(2));
      if ((S.memo || "").trim()) p.set("memo", (S.memo || "").trim().slice(0, 60));
      if (S.scaleBoost !== 1.0) p.set("scale", S.scaleBoost.toFixed(2));
      if (S.compare) p.set("cmp", "1");
      return p.toString();
    }

    function applyQueryToState() {
      const p = new URLSearchParams(location.search);

      const sph = Number(p.get("sph"));
      const idx = Number(p.get("idx"));
      const memoQ = p.get("memo");
      const scale = Number(p.get("scale"));
      const cmp = p.get("cmp") === "1";

      if (Number.isFinite(sph)) S.sph = clamp(roundTo(sph, 0.25), -10, -2);
      if (Number.isFinite(idx)) {
        const fixed = Number(idx.toFixed(2));
        if ([1.60, 1.67, 1.74].includes(fixed)) S.idx = fixed;
      }
      if (typeof memoQ === "string") S.memo = memoQ.slice(0, 60);
      if (Number.isFinite(scale)) S.scaleBoost = clamp(scale, 0.85, 1.35);
      S.compare = cmp;
    }

    function buildShareUrl() {
      const qs = stateToQuery();
      const url = new URL(location.href);
      url.search = qs;
      return url.toString();
    }

    async function shareCurrent() {
      const url = buildShareUrl();
      const title = "レンズ厚み比較（相対）";
      const text = `SPH ${fmtDiopter(S.sph)}D / 屈折率 ${Number(S.idx).toFixed(2)} の比較URLです。`;

      // Web Share API (if available)
      if (navigator.share) {
        try {
          await navigator.share({ title, text, url });
          return;
        } catch (e) {
          // user canceled or unsupported
        }
      }
      await safeCopy(url);
    }

    // -----------------------------
    // Events
    // -----------------------------
    function onSphChange(v) {
      const num = Number(v);
      if (!Number.isFinite(num)) return;
      S.sph = clamp(roundTo(num, 0.25), -10, -2);
      syncUIFromState();
      history.replaceState(null, "", "?" + stateToQuery());
    }

    function onIdxChange(v) {
      const num = Number(v);
      if (!Number.isFinite(num)) return;
      const fixed = Number(num.toFixed(2));
      if (![1.60, 1.67, 1.74].includes(fixed)) return;
      S.idx = fixed;
      syncUIFromState();
      history.replaceState(null, "", "?" + stateToQuery());
    }

    function onMemoChange(v) {
      S.memo = (v || "").slice(0, 60);
      updateTalkText();
      history.replaceState(null, "", "?" + stateToQuery());
    }

    function onScaleToggle() {
      // 3段階で視認性調整（接客で“差が小さく見える”問題を解決）
      const levels = [1.00, 1.18, 1.35];
      const idx = levels.findIndex(x => Math.abs(x - S.scaleBoost) < 0.02);
      S.scaleBoost = levels[(idx + 1) % levels.length];
      btnScale.textContent = S.scaleBoost === 1.00 ? "見やすく調整" : `表示倍率 x${S.scaleBoost.toFixed(2)}`;
      syncUIFromState();
      history.replaceState(null, "", "?" + stateToQuery());
    }

    function resetAll() {
      Object.assign(S, DEFAULT);
      setCompareMode(false);
      btnScale.textContent = "見やすく調整";
      syncUIFromState();
      history.replaceState(null, "", location.pathname);
    }

    // -----------------------------
    // Init
    // -----------------------------
    buildSphOptions();
    applyQueryToState();
    syncUIFromState();
    setCompareMode(S.compare);
    btnScale.textContent = S.scaleBoost === 1.00 ? "見やすく調整" : `表示倍率 x${S.scaleBoost.toFixed(2)}`;

    sphRange.addEventListener("input", (e) => onSphChange(e.target.value));
    sphSelect.addEventListener("change", (e) => onSphChange(e.target.value));
    idxSelect.addEventListener("change", (e) => onIdxChange(e.target.value));
    memo.addEventListener("input", (e) => onMemoChange(e.target.value));

    btnReset.addEventListener("click", resetAll);
    btnScale.addEventListener("click", onScaleToggle);

    btnToggleCompare.addEventListener("click", () => {
      setCompareMode(!S.compare);
      history.replaceState(null, "", "?" + stateToQuery());
    });

    btnShare.addEventListener("click", shareCurrent);

    btnCopyTalk.addEventListener("click", async () => {
      await safeCopy(talkText.textContent.trim());
    });

    // 画面サイズが変わった時もSVG見た目を崩しにくく（レンダリングはSVG自体が対応）
    window.addEventListener("resize", () => {
      if (S.compare) renderCompare();
    });
  </script>
</body>
</html>
